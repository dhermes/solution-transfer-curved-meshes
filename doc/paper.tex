\documentclass[letterpaper,10pt]{article}

\usepackage[margin=1in]{geometry}

\usepackage{amsthm,amssymb,amsmath,graphicx}
\usepackage{bm}
%% https://tex.stackexchange.com/a/396829/32270
\allowdisplaybreaks
%% H/T: https://tex.stackexchange.com/a/71153/32270
\usepackage[nottoc,notlot,notlof]{tocbibind}

\usepackage[usenames, dvipsnames]{color}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  urlcolor=blue,
  linkcolor=MidnightBlue,
  citecolor=ForestGreen,
  pdfinfo={
    CreationDate={D:20180822233421},
    ModDate={D:20180822233421},
  },
}

\usepackage{embedfile}
\embedfile{\jobname.tex}

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{High-order Solution Transfer between Curved Meshes}
\rhead{Danny Hermes}

%% H/T: https://tex.stackexchange.com/a/202047/32270
%%      https://tex.stackexchange.com/a/32463/32270
\usepackage[labelfont=bf]{caption}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\qed}{\(\blacksquare\)}
\newcommand{\reals}{\mathbf{R}}
\newcommand{\utri}{\mathcal{U}}

\begin{document}

\begin{abstract}
\noindent The problem of solution transfer between meshes arises frequently in
computational physics, e.g. in Lagrangian methods where remeshing
occurs. The interpolation process must be conservative, i.e. it
must conserve physical properties, such as mass. We extend previous
works --- which described the solution transfer process for straight sided
unstructured meshes --- by considering high-order isoparametric meshes
with curved elements. The implementation is highly reliant on accurate
computational geometry routines for evaluating points on and
intersecting B\'{e}zier curves and triangles.
\\ \\
\noindent \emph{Keywords}: Remapping, Curved Meshes, Lagrangian,
Solution Transfer, Numerical analysis
\end{abstract}

\tableofcontents

\section{Introduction}

The first part is a general-purpose tool for computational physics problems.
The tool enables solution transfer across two curved meshes.
Since the tool requires a significant amount of computational geometry, the
second half focuses on computational geometry. In particular, it considers
cases where the geometric methods used have seriously degraded accuracy due to
ill-conditioning.

In computational physics, the problem of solution transfer between meshes
occurs in several applications. For example, by allowing the underyling
computational domain to change during a simulation, computational
effort can be focused dynamically to resolve sensitive features
of a numerical solution. Mesh adaptivity (see, for example,
\cite{Babuska1978, Peraire1987, Pain2001}), this in-flight change in the mesh,
requires translating the numerical solution from the old mesh to the new,
i.e. solution transfer. As another example, Lagrangian or particle-based
methods treat each node in the mesh as a particle and so with each timestep the
mesh travels \emph{with} the fluid (see, for example, \cite{Hirt1974}).
However, over (typically limited) time the mesh
becomes distorted and suffers a loss in element quality which causes
catastrophic loss in the accuracy of computation. To overcome this, the
domain must be remeshed or rezoned and the solution must be
transferred (remapped) onto the new mesh configuration.

When pointwise interpolation is used to transfer a solution, quantities with
physical meaning (e.g. mass, concentration, energy) may not be conserved.
To address this, there have been many explorations (for example,
\cite{Jiao2004, Farrell2009, Farrell2011}) of
\emph{conservative interpolation} (typically using Galerkin or
\(L_2\)-minimizing methods). In this work, the author introduces a
conservative interpolation method for solution transfer between high-order
meshes. These high-order meshes are typically curved, but not necessarily
all elements or at all timesteps.

The existing work on solution transfer has considered straight sided meshes,
which use shape functions that have degree \(p = 1\) to represent solutions
on each element or so-called superparametric elements (i.e. a linear mesh
with degree \(p > 1\) shape functions on a regular grid of points).
However, both to allow for greater geometric flexibility
and for high order of convergence, this work will consider the case
of curved isoparametric\footnote{I.e. the degree of the discrete field on the
mesh is same as the degree of the shape functions that determine the
mesh.} meshes. Allowing curved geometries is useful since many practical
problems involve geometries that change over time, such as flapping flight
or fluid-structure interactions. In addition, high-order CFD methods
(\cite{Wang2013}) have the ability to produce highly accurate solutions
with low dissipation and low dispersion error.

\subsection{Overview}

This work is organized as follows. Section~\ref{sec:preliminaries}
establishes common notation and reviews basic results relevant to the
topics at hand. Section~\ref{sec:bezier-intersection} is an
in-depth discussion of the computational geometry methods needed
to implement to enable solution transfer. Section~\ref{sec:solution-transfer}
describes the solution transfer process and gives results of some
numerical experiments confirming the rate of convergence.

\section{Preliminaries}\label{sec:preliminaries}

\subsection{General Notation}

We'll refer to \(\reals\) for the reals, \(\utri\) represents
the unit triangle (or unit simplex) in \(\reals^2\):
\(\utri = \left\{(s, t) \mid 0 \leq s, t, s + t \leq 1\right\}\).
When dealing with sequences with multiple indices, e.g.
\(s_{m, n} = m + n\), we'll use bold symbols to represent
a multi-index: \(\bm{i} = (m, n)\). We'll use \(\left|\bm{i}\right|\) to
represent the sum of the components in a multi-index.
The binomial coefficient
\(\binom{n}{k}\) is equal to \(\frac{n!}{k! (n - k)!}\) and the trinomial
coefficient \(\binom{n}{i, j, k}\) is equal to \(\frac{n!}{i! j! k!}\)
(where \(i + j + k = n\)). The notation \(\delta_{ij}\) represents the
Kronecker delta, a value which is \(1\) when \(i = j\) and \(0\)
otherwise.

\subsection{B\'{e}zier Curves}

A \emph{B\'{e}zier curve} is a mapping from the unit interval
that is determined by a set of control points
\(\left\{\bm{p}_j\right\}_{j = 0}^n \subset \reals^d\).
For a parameter \(s \in \left[0, 1\right]\), there is a corresponding
point on the curve:
\begin{equation}
b(s) = \sum_{j = 0}^n \binom{n}{j} (1 - s)^{n - j} s^j \bm{p}_j \in
  \reals^d.
\end{equation}
This is a combination of the control points weighted by
each Bernstein basis function
\(B_{j, n}(s) = \binom{n}{j} (1 - s)^{n - j} s^j\).
Due to the binomial expansion
\(1 = (s + (1 - s))^n = \sum_{j = 0}^n B_{j, n}(s)\),
a Bernstein basis function is in
\(\left[0, 1\right]\) when \(s\) is as well. Due to this fact, the
curve must be contained in the convex hull of it's control points.

\subsection{B\'{e}zier Triangles}

A \emph{B\'{e}zier triangle} (\cite[Chapter~17]{Farin2001}) is a
mapping from the unit triangle
\(\utri\) and is determined by a control net
\(\left\{\bm{p}_{i, j, k}\right\}_{i + j + k = n} \subset \reals^d\).
A B\'{e}zier triangle is a particular kind of B\'{e}zier surface, i.e. one
in which there are two cartesian or three barycentric input parameters.
Often the term B\'{e}zier surface is used to refer to a tensor product or
rectangular patch.
For \((s, t) \in \utri\) we can define barycentric weights
\(\lambda_1 = 1 - s - t, \lambda_2 = s, \lambda_3 = t\) so that
\begin{equation}
1 = \left(\lambda_1 + \lambda_2 + \lambda_3\right)^n =
  \sum_{\substack{i + j + k = n \\ i, j, k \geq 0}} \binom{n}{i, j, k}
  \lambda_1^i \lambda_2^j \lambda_3^k.
\end{equation}
Using this we can similarly define a (triangular) Bernstein basis
\begin{equation}
B_{i, j, k}(s, t) = \binom{n}{i, j, k} (1 - s - t)^i s^j t^k
  = \binom{n}{i, j, k} \lambda_1^i \lambda_2^j \lambda_3^k
\end{equation}
that is in \(\left[0, 1\right]\) when \((s, t)\) is in \(\utri\).
Using this, we define points on the B\'{e}zier triangle as a
convex combination of the control net:
\begin{equation}
b(s, t) = \sum_{i + j + k = n} \binom{n}{i, j, k}
  \lambda_1^i \lambda_2^j \lambda_3^k
  \bm{p}_{i, j, k} \in \reals^d.
\end{equation}

\begin{figure}
  \includegraphics{main_figure01.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Cubic B\'{e}zier triangle}
  \label{fig:cubic-bezier-example}
\end{figure}

\noindent Rather than defining a B\'{e}zier triangle by the control net, it can
also be uniquely determined by the image of a standard lattice of
points in \(\utri\): \(b\left(j/n, k/n\right) = \bm{n}_{i, j, k}\);
we'll refer to these as \emph{standard nodes}.
Figure~\ref{fig:cubic-bezier-example} shows these standard nodes for
a cubic triangle in \(\reals^2\). To see the correspondence,
when \(p = 1\) the standard nodes \emph{are} the control net
\begin{equation}
b(s, t) = \lambda_1 \bm{n}_{1, 0, 0} +
\lambda_2 \bm{n}_{0, 1, 0} + \lambda_3 \bm{n}_{0, 0, 1}
\end{equation}
and when \(p = 2\)
\begin{multline}
b(s, t) = \lambda_1\left(2 \lambda_1 - 1\right) \bm{n}_{2, 0, 0} +
\lambda_2\left(2 \lambda_2 - 1\right) \bm{n}_{0, 2, 0} +
\lambda_3\left(2 \lambda_3 - 1\right) \bm{n}_{0, 0, 2} + \\
4 \lambda_1 \lambda_2 \bm{n}_{1, 1, 0} +
4 \lambda_2 \lambda_3 \bm{n}_{0, 1, 1} +
4 \lambda_3 \lambda_1 \bm{n}_{1, 0, 1}.
\end{multline}
However, it's worth noting that the transformation between
the control net and the standard nodes has condition
number that grows exponentially with \(n\) (see \cite{Farouki1991}, which
is related but does not directly show this).
This may make working with
higher degree triangles prohibitively unstable.

A \emph{valid} B\'{e}zier triangle is one which is
diffeomorphic to \(\utri\), i.e. \(b(s, t)\) is bijective and has
an everywhere invertible Jacobian. We must also have the orientation
preserved, i.e. the Jacobian must have positive determinant. For example, in
Figure~\ref{fig:inverted-element}, the image of \(\utri\) under
the map \(b(s, t) = \left[\begin{array}{c c} (1 - s - t)^2 + s^2 & s^2 + t^2
\end{array}\right]^T\) is not valid because the Jacobian is zero along
the curve \(s^2 - st - t^2 - s + t = 0\) (the dashed line). Elements that
are not valid are called \emph{inverted} because they have regions with
``negative area''. For the example, the image \(b\left(\utri\right)\)
leaves the boundary determined by the edge curves: \(b(r, 0)\),
\(b(1 - r, r)\) and \(b(0, 1 - r)\) when \(r \in \left[0, 1\right]\).
This region outside the boundary is traced twice, once with
a positive Jacobian and once with a negative Jacobian.
\begin{figure}
  \includegraphics{inverted_element.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{The B\'{e}zier triangle given by \(b(s, t) = \left[
    (1 - s - t)^2 + s^2 \; \; s^2 + t^2 \right]^T\) produces an
    inverted element. It traces the same region twice, once with
    a positive Jacobian (the middle column) and once with a negative
    Jacobian (the right column).}
  \label{fig:inverted-element}
\end{figure}

\subsection{Curved Elements}\label{sec:curved-elements}

We define a curved mesh element \(\mathcal{T}\) of degree \(p\)
to be a B\'{e}zier triangle in \(\reals^2\) of the same degree.
We refer to the component functions of \(b(s, t)\) (the map that
gives \(\mathcal{T} = b\left(\utri\right)\)) as \(x(s, t)\) and \(y(s, t)\).

This fits a typical definition (\cite[Chapter~12]{FEM-ClaesJohnson})
of a curved element, but gives a special meaning to the mapping from
the reference triangle. Interpreting elements as B\'{e}zier triangles
has been used for Lagrangian methods where
mesh adaptivity is needed (e.g. \cite{CardozeMOP04}). Typically curved
elements only have one curved side (\cite{McLeod1972}) since they are used
to resolve geometric features of a boundary. See also
\cite{Zlmal1973, Zlmal1974}.
B\'{e}zier curves and triangles have a number of mathematical properties
(e.g. the convex hull property) that lead to elegant geometric
descriptions and algorithms.

Note that a B\'{e}zier triangle can be
determined from many different sources of data (for example the control net
or the standard nodes). The choice of this data may be changed to suit the
underlying physical problem without changing the actual mapping. Conversely,
the data can be fixed (e.g. as the control net) to avoid costly basis
conversion; once fixed, the equations of motion and other PDE terms can
be recast relative to the new basis (for an example, see \cite{Persson2009},
where the domain varies with time but the problem is reduced to
solving a transformed conservation law in a fixed reference configuration).

\subsection{Shape Functions}\label{subsec:shape-functions}

When defining shape functions (i.e. a basis with geometric meaning) on a
curved element there are (at least) two choices. When the degree of the
shape functions is the same as the degree of the function being
represented on the B\'{e}zier triangle,
we say the element \(\mathcal{T}\) is \emph{isoparametric}.
For the multi-index
\(\bm{i} = (i, j , k)\), we define \(\bm{u}_{\bm{i}} =
\left(j/n, k/n\right)\) and the corresponding standard node
\(\bm{n}_{\bm{i}} = b\left(\bm{u}_{\bm{i}}\right)\).
Given these points, two choices for shape functions present
themselves:
\begin{itemize}
  \itemsep 0em
  \item \emph{Pre-Image Basis}:
    \(\phi_{\bm{j}}\left(\bm{n}_{\bm{i}}\right) =
      \widehat{\phi}_{\bm{j}}\left(\bm{u}_{\bm{i}}\right) =
      \widehat{\phi}_{\bm{j}}\left(b^{-1}\left(
      \bm{n}_{\bm{i}}\right)\right)\)
    where \(\widehat{\phi}_{\bm{j}}\) is a canonical basis function
    on \(\utri\), i.e.
    \(\widehat{\phi}_{\bm{j}}\) a degree \(p\) bivariate polynomial and
    \(\widehat{\phi}_{\bm{j}}\left(\bm{u}_{\bm{i}}\right) =
    \delta_{\bm{i} \bm{j}}\)
  \item \emph{Global Coordinates Basis}:
    \(\phi_{\bm{j}}\left(\bm{n}_{\bm{i}}\right) =
    \delta_{\bm{i} \bm{j}}\), i.e. a canonical basis function
    on the standard nodes \(\left\{\bm{n}_{\bm{i}}\right\}\).
\end{itemize}

\noindent For example, consider a quadratic B\'{e}zier triangle:
\begin{gather}
b(s, t) = \left[ \begin{array}{c c}
    4 (s t + s + t) & 4 (s t + t + 1)
  \end{array}\right]^T \\
\Longrightarrow
\left[ \begin{array}{c c c c c c}
    \bm{n}_{2, 0, 0} &
    \bm{n}_{1, 1, 0} &
    \bm{n}_{0, 2, 0} &
    \bm{n}_{1, 0, 1} &
    \bm{n}_{0, 1, 1} &
    \bm{n}_{0, 0, 2}
  \end{array}\right] = \left[ \begin{array}{c c c c c c}
    0 & 2 & 4 & 2 & 5 & 4 \\
    4 & 4 & 4 & 6 & 7 & 8
  \end{array}\right].
\end{gather}
In the \emph{Global Coordinates Basis}, we have
\begin{equation}
\phi^{G}_{0, 1, 1}(x, y) = \frac{(y - 4) (x - y + 4)}{6}.
\end{equation}
For the \emph{Pre-Image Basis}, we need the inverse
and the canonical basis
\begin{equation}
b^{-1}(x, y) = \left[ \begin{array}{c c}
    \frac{x - y + 4}{4} & \frac{y - 4}{x - y + 8}
  \end{array}\right] \quad \text{and} \quad
\widehat{\phi}_{0, 1, 1}(s, t) = 4 s t
\end{equation}
and together they give
\begin{equation}
\phi^{P}_{0, 1, 1}(x, y) = \frac{(y - 4) (x - y + 4)}{x - y + 8}.
\end{equation}
In general \(\phi_{\bm{j}}^P\) may not even be a rational bivariate
function; due to composition with \(b^{-1}\) we can only guarantee that
it is algebraic (i.e. it can be defined as the zero set of polynomials).

\subsection{Curved Polygons}\label{subsec:curved-polygons}

\begin{figure}
  \includegraphics{main_figure26.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Intersection of B\'{e}zier triangles form a curved polygon.}
  \label{fig:bezier-triangle-intersect}
\end{figure}

When intersecting two curved elements, the resulting surface(s) will
be defined by the boundary, alternating between edges of each
element.
For example, in Figure~\ref{fig:bezier-triangle-intersect}, a
``curved quadrilateral'' is formed when two B\'{e}zier triangles
\(\mathcal{T}_0\) and \(\mathcal{T}_1\) are intersected.

A \emph{curved polygon} is defined by a collection of B\'{e}zier curves
in \(\reals^2\) that determine the boundary. In order to be
a valid polygon, none of the boundary curves may cross, the
ends of consecutive edge curves must meet and the curves must be right-hand
oriented. For our example in
Figure~\ref{fig:bezier-triangle-intersect}, the triangles
have boundaries formed by three B\'{e}zier curves:
\(\partial \mathcal{T}_0 = b_{0, 0} \cup b_{0, 1} \cup b_{0, 2}\) and
\(\partial \mathcal{T}_1 = b_{1, 0} \cup b_{1, 1} \cup b_{1, 2}\).
The intersection \(\mathcal{P}\) is defined by four boundary
curves: \(\partial \mathcal{P} =
C_1 \cup C_2 \cup C_3 \cup C_4\). Each boundary
curve is itself a B\'{e}zier curve\footnote{A specialization of a
B\'{e}zier curve \(b\left(\left[a_1, a_2\right]\right)\)
is also a B\'{e}zier curve.}:
\(C_1 = b_{0, 0}\left(\left[0, 1/8\right]\right)\),
\(C_2 = b_{1, 2}\left(\left[7/8, 1\right]\right)\),
\(C_3 = b_{1, 0}\left(\left[0, 1/7\right]\right)\) and
\(C_4 = b_{0, 2}\left(\left[6/7, 1\right]\right)\).

Though an intersection can be described in terms of the B\'{e}zier triangles,
the structure of the control net will be lost. The region will not in general
be able to be described by a mapping from a simple space like
\(\utri\).

\section{B\'{e}zier Intersection Problems}\label{sec:bezier-intersection}

\subsection{Intersecting B\'{e}zier Curves}

The problem of intersecting two B\'{e}zier curves is a core building
block for intersecting two B\'{e}zier triangles in \(\reals^2\)
Since a curve is an algebraic variety of dimension one,
the intersections will either be a curve segment common to both curves (if
they coincide) or a finite set of points (i.e. dimension zero).
Many algorithms have been described in the literature, both
geometric (\cite{Sederberg1986, Sederberg1990, Kim1998}) and
algebraic (\cite{Manocha:CSD-92-698}).

In the implementation for this work, the B\'{e}zier subdivision
algorithm is used.
In the case of a transversal intersection (i.e. one where the
tangents to each curve are not parallel and both are non-zero),
this algorithm performs very well. However, when curves are tangent,
a large number of (false) candidate intersections are detected and
convergence of Newton's method slows once in a neighborhood of an
actual intersection. Non-transversal intersections
have infinite condition number, but transversal intersections with
very high condition number can also cause convergence problems.

\begin{figure}
  \includegraphics{bbox_check.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Bounding box intersection predicate. This is a cheap way to
    conclude that two curves don't intersect, though it inherently is
    susceptible to false positives.}
  \label{fig:bounding-box-check}
\end{figure}

In the B\'{e}zier subdivision algorithm, we first check if the
bounding boxes for the curves are disjoint
(Figure~\ref{fig:bounding-box-check}).
We use the bounding boxes
rather than the convex hulls since they are easier to compute and
the intersections of boxes are easier to check.
If they are disjoint, the pair can be rejected. If not, each curve
\(\mathcal{C} = b\left(\left[0, 1\right]\right)\) is split into two halves
by splitting the unit interval: \(b\left(\left[0, \frac{1}{2}\right]\right)\)
and \(b\left(\left[\frac{1}{2}, 1\right]\right)\)
(Figure~\ref{fig:bezier-curve-subdivision}).

\begin{figure}
  \includegraphics{subdivide_curve.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{B\'{e}zier curve subdivision.}
  \label{fig:bezier-curve-subdivision}
\end{figure}

\begin{figure}
  \includegraphics{subdivision_process.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{B\'{e}zier subdivision algorithm.}
  \label{fig:bezier-subdivision-process}
\end{figure}

As the subdivision continues,
some pairs of curve segments may be kept around that won't lead to an
intersection (Figure~\ref{fig:bezier-subdivision-process}).
Once the curve segments are close to linear within a given tolerance
(Figure~\ref{fig:bezier-subdivision-linearized}), the process
terminates.

\begin{figure}
  \includegraphics{subdivision_linearized.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Subdividing until linear within tolerance.}
  \label{fig:bezier-subdivision-linearized}
\end{figure}

Once both curve segments are linear (to tolerance), the intersection is
approximated by intersecting the lines connecting the endpoints of each
curve segment. This approximation is used as a starting point for Newton's
method, to find a root of \(F(s, t) = b_0(s) - b_1(t)\). Since
\(b_0(s), b_1(t) \in \reals^2\) we have Jacobian \(J =
\left[ \begin{array}{c c} b_0'(s) & -b_1'(t) \end{array}\right]\).
With these, Newton's method is
\begin{equation}
\left[ \begin{array}{c c} s_{n + 1} & t_{n + 1} \end{array}\right]^T =
\left[ \begin{array}{c c} s_n & t_n \end{array}\right]^T -
J_n^{-1} F_n.
\end{equation}
This also gives an indication why convergence issues occur at non-transveral
intersections: they are exactly the intersections where the Jacobian is
singular.

\subsection{Intersecting B\'{e}zier Triangles}\label{subsec:intersect-bez-tri}

The chief difficulty in intersecting two surfaces is intersecting their edges,
which are B\'{e}zier curves.
Though this is just a part of the overall algorithm, it proved to be the
\emph{most difficult} to implement (\cite{Hermes2017}). So the first part
of the algorithm is to find all points
where the edges intersect (Figure~\ref{fig:edge-intersections}).

\begin{figure}
  \includegraphics{main_figure21.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Edge intersections during B\'{e}zier triangle intersection.}
  \label{fig:edge-intersections}
\end{figure}

To determine the curve segments that bound the curved polygon region(s)
(see Section~\ref{subsec:curved-polygons} for more about curved polygons) of
intersection, we not only need to keep track
of the coordinates of intersection, we also need to keep note of
\emph{which} edges the intersection occurred on and the parameters along
each curve.
With this information, we can classify each point of intersection
according to which of the two curves forms the boundary of the
curved polygon (Figure~\ref{fig:intersection-classification}).
Using the right-hand rule we can compare the tangent
vectors on each curve to determine which one is on the interior.

\begin{figure}
  \includegraphics{main_figure22.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Classified intersections during B\'{e}zier triangle intersection.}
  \label{fig:intersection-classification}
\end{figure}

This classification becomes more difficult when the curves
are tangent at an intersection, when the intersection occurs at a corner
of one of the surfaces or when two intersecting edges are coincident
on the same algebraic curve (Figure~\ref{fig:intersection-difficulties}).

\begin{figure}
  \includegraphics{main_figure23.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{B\'{e}zier triangle intersection difficulties.}
  \label{fig:intersection-difficulties}
\end{figure}

In the case of tangency, the intersection is non-transversal, hence has
infinite condition number. In the case of coincident curves, there are
infinitely many intersections (along the segment when the curves
coincide) so the subdivision process breaks down.

\subsubsection{Example}

Consider two B\'{e}zier surfaces
(Figure~\ref{fig:surface-surface-example})

\begin{equation}
b_0(s, t) =
\left[ \begin{array}{c}
    8 s \\ 8 t \end{array}\right] \qquad
b_1(s, t) =
\left[ \begin{array}{c}
    2 (6 s + t - 1) \\
    2 (8 s^2 + 8 s t - 8 s + 3 t + 2) \end{array}\right]
\end{equation}
\begin{figure}
  \includegraphics{main_figure24.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Surface Intersection Example}
  \label{fig:surface-surface-example}
\end{figure}

In the \emph{first step} we find all intersections of the
edge curves
\begin{multline}
E_0(r) = \left[ \begin{array}{c} 8 r \\ 0 \end{array}\right],
E_1(r) = \left[ \begin{array}{c} 8 (1 - r) \\ 8 r \end{array}\right],
E_2(r) = \left[ \begin{array}{c} 0 \\ 8 (1 - r) \end{array}\right], \\
E_3(r) = \left[ \begin{array}{c} 2 (6 r - 1) \\ 4 (2 r - 1)^2
  \end{array}\right],
E_4(r) = \left[ \begin{array}{c} 10 (1 - r) \\ 2 (3 r + 2) \end{array}\right],
E_5(r) = \left[ \begin{array}{c} - 2 r \\ 2 (5 - 3 r) \end{array}\right].
\end{multline}
We find three intersections
and we classify each of them by comparing the tangent vectors
\begin{gather}
  I_1:
  E_2\left(\frac{7}{9}\right) =
E_3\left(\frac{1}{6}\right) = \frac{16}{9}
\left[ \begin{array}{c} 0 \\ 1 \end{array}\right] \Longrightarrow
E_2'\left(\frac{7}{9}\right) \times
E_3'\left(\frac{1}{6}\right) = 96 \\
I_2:
E_0\left(\frac{1}{2}\right) =
E_3\left(\frac{1}{2}\right) =
\left[ \begin{array}{c} 4 \\ 0 \end{array}\right] \Longrightarrow
E_0'\left(\frac{1}{2}\right) \times
E_3'\left(\frac{1}{2}\right) = 0 \\
  I_3:
E_1\left(\frac{1}{8}\right) =
E_3\left(\frac{3}{4}\right) =
\left[ \begin{array}{c} 7 \\ 1 \end{array}\right] \Longrightarrow
E_1'\left(\frac{1}{8}\right) \times
E_3'\left(\frac{3}{4}\right) = -160.
\end{gather}
From here, we construct our curved polygon intersection by drawing
from our list of intersections until none remain.

\begin{itemize}
\itemsep 0em
\item First consider \(I_1\). Since
  \(E_2' \times
  E_3' > 0\)
  at this point, then we consider the curve
  \(E_3\) to be
  \emph{interior}.
\item After classification, we move along
  \(E_3\) until we
  encounter another intersection: \(I_2\)
\item \(I_2\) is a point of tangency since
  \(E_0'\left(\frac{1}{2}\right) \times
  E_3'\left(\frac{1}{2}\right) = 0\).
  Since a tangency has no impact on
  the underlying intersection geometry, we ignore it and
  keep moving.
\item Continuing to move along
  \(E_3\), we
  encounter another intersection: \(I_3\).
  Since
  \(E_1' \times
  E_3' < 0\)
  at this point, we consider the curve
  \(E_1\) to be
  \emph{interior} at the intersection. Thus we stop moving
  along \(E_3\)
  and we have our first curved segment:
  \(E_3\left(\left[
    \frac{1}{6}, \frac{3}{4}\right]\right)\)
\item Finding no other intersections on \(E_1\)
  we continue until the end of the edge.
  Now our (ordered) curved segments are:
  \begin{equation}
  E_3\left(\left[
    \frac{1}{6}, \frac{3}{4}\right]\right) \longrightarrow
  E_1\left(\left[
    \frac{1}{8}, 1\right]\right).
  \end{equation}
\item Next we stay at the corner and switch to the next curve
  \(E_2\), moving along that curve
  until we hit the next intersecton \(I_1\).
  Now our (ordered) curved segments are:
  \begin{equation}
  E_3\left(\left[
    \frac{1}{6}, \frac{3}{4}\right]\right) \longrightarrow
  E_1\left(\left[
    \frac{1}{8}, 1\right]\right) \longrightarrow
  E_2\left(\left[
    0, \frac{7}{9}\right]\right).
  \end{equation}
  Since we are now back where we started (at \(I_1\))
  the process stops
\end{itemize}
We represent the boundary of the curved polygon as B\'{e}zier curves, so
to complete the process we reparameterize (\cite[Ch.~5.4]{Farin2001}) each
curve onto the relevant interval. For example,
\(E_3\) has control points
\(p_0 = \left[ \begin{array}{c} -2 \\ 4 \end{array}\right]\),
\(p_1 = \left[ \begin{array}{c} 4 \\ -4 \end{array}\right]\),
\(p_2 = \left[ \begin{array}{c} 10 \\ 4 \end{array}\right]\)
and we reparameterize on \(\alpha = \frac{1}{6}, \beta = \frac{3}{4}\) to
control points
\begin{align}
  q_0 &= E_3\left(\frac{1}{6}\right) =
  \frac{16}{9} \left[ \begin{array}{c} 0 \\ 1 \end{array}\right] \\
  q_1 &= (1 - \alpha) \left[(1 - \beta) p_0 + \beta p_1\right] +
   \alpha \left[(1 - \beta) p_1 + \beta p_2\right] = \frac{1}{6} \left[
    \begin{array}{c} 21 \\ -8 \end{array}\right] \\
  q_2 &= E_3\left(\frac{3}{4}\right) = \left[
    \begin{array}{c} 7 \\ 1 \end{array}\right].
\end{align}

\subsection{B\'{e}zier Triangle Inverse}

The problem of determining the parameters \((s, t)\) given a point
\(\bm{p} = \left[\begin{array}{c c} x & y\end{array}\right]^T\)
in a B\'{e}zier triangle can also be solved by using
subdivision with a bounding box predicate and then Newton's method
at the end.

\begin{figure}
  \includegraphics{locate_in_triangle.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Checking for a point \(\bm{p}\) in each of four subregions
    when subdividing a B\'{e}zier triangle.}
  \label{fig:locate-in-triangle}
\end{figure}

For example, Figure~\ref{fig:locate-in-triangle} shows
how regions of \(\utri\) can be discarded recursively until the
suitable region for \((s, t)\) has a sufficiently small area. At
this point, we can apply Newton's method to the map \(F(s, t) =
b(s, t) - \bm{p}\). It's very helpful (for Newton's method) that
\(F: \reals^2 \longrightarrow \reals^2\) since the Jacobian will
always be invertible
when the B\'{e}zier triangle is valid. If \(\bm{p} \in \reals^3\)
then the system would be underdetermined. Similarly, if
\(\bm{p} \in \reals^2\) but \(b(s)\) is a B\'{e}zier curve then the
system would be overdetermined.

\section{Solution Transfer}\label{sec:solution-transfer}

Placeholder.

\section{Conclusion}

This work has described a method for conservative interpolation
between curved meshes. The transfer process conserves globally
to machine precision since we can use exact quadratures for all
integrals. The primary source of error comes from solving the linear
system with the mass matrix for the target mesh. This allows
less restrictive usage of mesh adaptivity, which can make computations
more efficient. Additionally, having a global transfer algorithm
allows for remeshing to be done less frequently.

The algorithm breaks down into three core subproblems: B\'{e}zier triangle
intersection, an advancing front for intersecting elements and
integration on curved polygons. The inherently local nature of the
advancing front allows the algorithm to be parallelized via domain
decomposition with little data shared between processes. By
restricting integration to the intersection of elements from the
target and donor meshes, the algorithm can accurately transfer
both continuous and discontinuous fields.

\subsection{Future Work}

As mentioned in the preceding chapters, there are several research
directions possible to build upon the solution transfer algorithm.
The usage of Green's theorem nicely extends to \(\reals^3\) via
Stoke's theorem, but the B\'{e}zier triangle intersection algorithm
is specific to \(\reals^2\). The equivalent B\'{e}zier tetrahedron
intersection algorithm is significantly more challenging.

The restriction to shape functions from the global coordinates basis
is a symptom of the method and not of the inherent problem. The
pre-image basis has several appealing properties, for example
this basis can be precomputed on \(\utri\). The problem of a
valid tessellation of a curved polygon warrants more exploration.
Such a tessellation algorithm would enable usage of the pre-image
basis.

The usage of the global coordinates basis does have some benefits.
In particular, the product of shape functions from different meshes
is still a polynomial in \(\reals^2\). This means that we could
compute the coefficients of \(F = \phi_0 \phi_1\) directly and
use them to evaluate the antiderivatives \(H\) and \(V\) rather
than using the fundamental theorem of calculus. Even if this
did not save any computation, it may still be preferred over
the FTC approach because it would remove the usage of quadrature
points outside of the domain \(\mathcal{P}\).

\bibliography{paper}
\bibliographystyle{alpha}

\end{document}
